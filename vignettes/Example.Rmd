---
title: "Using the hookCompetition package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hookCompetition}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(fig.width=12, fig.height=8) 
```

```{r setup}
library(hookcompetition)
library(sp)
library(inlabru)
```

```{r loadhiddenfunctions, include=F, echo=F}
colsc <- function(...) {
  ggplot2::scale_fill_gradientn(colours = rev(RColorBrewer::brewer.pal(11,"RdYlBu")),
                       limits = range(..., na.rm=TRUE))
}
```


## How to use the hookCompetition package

This markdown document will outline the steps needed to use the hookCompetition package.

# Step 1 - Setting the initial values.

```{r loadpackage}
#library(hookcompetition)
# Set the number of cores to use to generate the vignette
n_cores <- 1
# Set the number of samples to use for bootstrapping for Monte Carlo approximations to posterior quantities. Should be set much higher for real applications!
n_samp <- 100
```

# Step 2 - Loading the data.

The function `read_Data_hookcomp()` achieves this. The arguments to the function are:

- `species_vec` is a character vector of the one or more species desired for modelling
- `at_PBS` is a logical flag determining if the user has access to the gf data. If FALSE, yelloweye rockfish must be the specified species. 
- `simple_species_vec` is a character vector containing the desired shortened names of the species
- `data_wd` is a character vector stating the working directory where the rds files will be saved
- `min_dist` is a numeric stating the minimum distance (km) required for a temporary IPHC station to be from a permanent IPHC station to be included
- `min_dist_to_boundary` is a numeric stating the minimum distance (km) required for an IPHC station to be from the survey boundary
- `years_all_vec` is a numeric vector stating the years all hooks were enumerated
- `years_20_vec` is a numeric vector stating the years only 20 hooks were enumerated
- `survey_boundaries`   # survey_boundaries is a SpatialPolygonsDataFrame object containing user-specified survey boundaries for indices to be computed in. If NULL QCS, WCHG, WCVI, HS used. The data.frame *must* contain a factor variable `Region` with levels equal to the names of the regions
- `preserve_inter_regional_differences` Logical. If `TRUE` the relative magnitudes in catch rates between the subregions are preserved. If `FALSE` the catch rates are normalized separately within each subregion. Use the latter if differences in absolute abundances between regions are not desired and only temporal trends *within* each subregion are desired. 


```{r loaddata, message=F, warning=F, cache=T}

data <- hookcompetition::read_Data_hookcomp(
  species_vec = 'yelloweye rockfish',
  simple_species_vec = 'yelloweye',
  at_PBS = F,
  data_wd = './',
  min_dist = 50,
  min_dist_to_boundary = 0,
  years_all_vec = c(1995,1996,2003:2012, 2014:2019),
  years_20_vec = c(1997:2002, 2013, 2020),
  survey_boundaries=NULL
)

```

The function `read_Data_hookcomp()` returns a list containing two entries:
- `Reduced_data_sp` is a SpatialPointsDataFrame containing all the set-level catch counts of the species specified (variable name `N_it_yelloweye`).
- `survey_boundaries` are the survey boundaries projected into the same CRS as the `Reduced_data_sp` object.

To put the objects in the list into the current working environment, run the following:

```{r environment, message=FALSE, warning=FALSE}
list2env(data, globalenv())
rm(data)
```


# Step 3 - Fit the indices without the spatio-temporal random effects. 

We derive bootstrap indices for a set of test species using the function `bootstrap_index_fun_run`. We derive an overall index and a subregion index (with subregions defined by the survey boundaries).

The function `bootstrap_index_fun_run` takes as arguments:

- `data` a SpatialPointsDataFrame object containing the IPHC data
- `species` a character name of the species (linked to the variables `N_it` in the dataframe)
- `survey_boundaries` a SpatialPolygonsDataFrame object containing the survey boundary definitions
- `R` specifies the number of bootstrap samples desired
- `ncpus` specifies the number of cores to use in parallel
- `type` specifies the type of bootstrap intervals to use (default percentile)
- `return` when TRUE it returns the indices
- `plot` when TRUE it returns the plot. 

```{r bootstrap, cache=T, warning=F, message=F}
bootstrap_ind <-
bootstrap_index_fun_run(species_vec = 'yelloweye',
                          data = Reduced_data_sp,
                          survey_boundaries = survey_boundaries,
                          R=n_samp,
                          return=T,
                          ncpus=n_cores,
                          type='perc',
                          plot=T
                          )

```

We derive hook-competition-adjusted bootstrap indices using the same function `bootstrap_index_fun_run()`, but adding the argument `ICR_adjust=TRUE`. We derive an overall index and a subregion index (with subregions defined by the survey boundaries).


```{r bootstrap_compfactor, cache=T, warning=F, message=F}
bootstrap_ind_compfactor <-
bootstrap_index_fun_run(species_vec = 'yelloweye',
                          data = Reduced_data_sp,
                          ICR_adjust=T,
                          survey_boundaries = survey_boundaries,
                          R=n_samp,
                          return=T,
                          ncpus=n_cores,
                          type='perc',
                          plot=T
                          )
```

Finally, we compute Poisson-lognormal model-based indices of relative abundance. These include the CPUE-based (unadjusted), hook-competition-adjusted (ICR-based), and censored likelihood-based indices. 

To compute all three indices we use the function `censored_index_fun` with arguments:

- `data`
- `species`
- `survey_boundaries`
- `M` the number of independent Monte Carlo samples from the posterior used to compute indices
- `return` logical stating whether or not to return indices as a data.frame
- `ICR_adjust` A logical determining if the ICR-based scale-factor adjustment should be used
- `cprop` the minimum proportion of baits needed to induce censorship
- `nthreads` how many cores do you want to run in parallel when fitting the model
- `keep` a logical stating if you want to return the INLA model object
- `use_upper_bound` a logical stating if right-censored or interval-censored is desired
- `upper_bound_quantile` a proportion stating which quantiles of observation to remove censorship from. If greater than 1, do not remove censorship from any observation
- `plot` logical
- `allyears` logical determining if upper bound quantile is computed uniquely for each year (if False) or over all years (if TRUE)
- `station_effects` logical stating if IID station-station random effects wanted
- `prior_event` a prior distribution for the event-event IID random effect standard deviation (see HT.prior for default half t_7(0,1) distribution)
- `prior_station` a prior distribution for the station-station IID random effect standard deviation (see HT.prior for default half t_7(0,1) distribution)
- `init_vals` initial values for fitting model. If NULL let INLA choose them.
- `n_knots` the number of knots used for the temporal 'spline'. Default is 8. More knots means a 'wigglier' temporal effect is allowed.
- `seed` the seed used for Monte Carlo sampling. Note that 0 means the result is non-reproducible, but the code can be significantly faster.
- `verbose` logical. If TRUE, show INLA diagnostics as the model fits. Can help to diagnose issues.
- `n_trajectories` integer specifying how many Monte Carlo sampled relative abundance indices to plot on a spaghetti plot. This can help with interpreting uncertainty. Suggested value 10. 
- `preserve_inter_regional_differences` Logical

We now fit all three indices

```{r model-based, cache=F, warning=F, message=F}
CPUE_ind <-
censored_index_fun(
  data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=F, cprop=1.1, nthreads=n_cores, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = c(0.228, -2.346, 2.407, -0.586), n_knots=8, seed=0, verbose=T, n_trajectories=10,
  preserve_inter_regional_differences = F
)

ICR_ind <-
censored_index_fun(
  data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=T, cprop=1.1, nthreads=n_cores, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = c(0.228, -2.346, 2.407, -0.586), n_knots=8, seed=0, verbose=T, n_trajectories=10,
  preserve_inter_regional_differences = F
)

# The following model does not converge
# censored_ind <-
# censored_index_fun(
#   data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=F, cprop=0.95, nthreads=n_cores, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = NULL, n_knots=8, seed=0, verbose=F, n_trajectories=10
#     )

# Use upper bound and lower upper_bound_quantile to 0.98
# Model now converges
censored_ind <-
censored_index_fun(
  data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=F, cprop=0.95, nthreads=n_cores, keep=F, use_upper_bound=TRUE, upper_bound_quantile=0.95, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = c(0.228, -2.346, 2.407, -0.586), n_knots=8, seed=0, verbose=T, n_trajectories=10,
  preserve_inter_regional_differences = F
    )

```

## Bonus

The package also allows for spatio-temporal indices to be fit

Step 5 load the R objects required for fitting spatio-temporal models. These include: a delauney triangulation mesh for computing the GMRF approximation to the SPDE (cite Lindgren) within r-INLA (cite Rue); an INLA spde object with user-specified pc priors specified on the range and standard deviation parameters. Note that the spde object is a barrier model (cite Bakka) which accounts for land as a barrier.

The function `make_spatial_objects()` achieves this. It takes arguments:

- `data` a SpatialPointsDataFrame object containing the IPHC data
- `survey_boundaries` a SpatialPolygonsDataFrame object containing the survey boundary definitions
- `mesh_coast` a simplified (smoothed) SpatialPolygonsDataFrame object over which the triangulation mesh will be created. If NULL, a simplified shapefile of BC Coastline will be returned.
- `hires_coast` a high-resolution SpatialPolygonsDataFrame object used for plotting. If NULL, a default BC coastline object will be returned.
- `prior_range` Choose a value in kilometres such that the species density at two locations separated by distances greater than this will be `approximately' independent (typically a lower bound is chosen).
- `prior_range_prob` What is you prior probability that the spatial range will be smaller than this value (typically a small probability)?
- `prior_sigma` Choose a value for the marginal standard deviation of the random field. Typically an upper bound is used. Remember our linear predictor is on the log scale, so think about constraining exp(+- 2*SD) in terms of multiplicative regional differences. 
- `prior_sigma_prob` What is your prior probability that the true marginal standard deviation exceeds this?

```{r makespatialobj, cache=T, warning=F, message=F}
spatial_obj <- make_spatial_objects(
  data=Reduced_data_sp,
  survey_boundaries = survey_boundaries,
  mesh_coast = NULL, hires_coast = NULL, 
  prior_range = 20, prior_range_prob = 0.01,
  prior_sigma = 2, prior_sigma_prob = 0.01 
)

# load it into the global envirionment
list2env(spatial_obj, globalenv())
rm(spatial_obj)

ggplot2::ggplot() + inlabru::gg(mesh) + inlabru::gg(Reduced_data_sp)

```

# Step 6 Fit the spatio-temporal indices

The following code *would* be run to make spatio-temporal indices of yelloweye abundance. We do not run the code to save time whilst generating this vignette. Instead, we load pre-compiled objects. Note, we removed map predictions from all years except 2000 to save space.

The function `spatiotemp_censored_index_fun()` is used to fit the spatio-temporal indices. It takes arguments (the new ones are described):

- `data` 
- `survey_boundaries` 
- `species` 
- `M`
- `return`
- `ICR_adjust` 
- `cprop`
- `nthreads` 
- `keep` 
- `use_upper_bound` 
- `upper_bound_quantile` 
- `plot`
- `allyears` 
- `station_effects` 
- `prior_event` 
- `prior_station` 
- `init_vals` 
- `n_knots` 
- `seed` 
- `mesh` An INLA mesh object (e.g. `mesh` created in `make_spatial_objects()`)
- `spde` An INLA spde object (e.g. `spde_mod` created in `make_spatial_objects()`)
- `pixels` A SpatialPixelsDataFrame object used for plotting the maps of relative abundance
- `covs` Currently not implemented. Please let me know if (spatio-temporal) environmental covariate functionality is wanted in a future version.
- `spatiotemporal` Logical. Do you want to identify temporal changes in relative abundance uniquely across space? Almost always yes.
- `n_trajectories` integer specifying how many Monte Carlo sampled relative abundance indices to plot on a spaghetti plot. This can help with interpreting uncertainty. Suggested value 10. 
- `preserve_inter_regional_differences` Logical

Note that *these models can take a while to run (5-30 minutes)*. We advise you to set verbose=T so that you can assure yourself that something useful is happening behind the scenes :)

```{r spatiotemporal, eval=F, cache=F, warning=F, message=F}

spatio_temporal_CPUE_ind <-
  spatiotemp_censored_index_fun(data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=F, cprop=1.1, nthreads=n_cores, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = c(0.385, -2.083, 2.711, -0.861, 4.000, 0.200, 3.400, 0.300, 2.938), n_knots=8, seed=0, mesh=mesh, spde=spde_mod, pixels=predict_pixels, covs=NULL, spatiotemporal=T, verbose = F, n_trajectories = 10,
  preserve_inter_regional_differences = F)


spatio_temporal_ICR_ind <-
  spatiotemp_censored_index_fun(data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=T, cprop=1.1, nthreads=n_cores, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = NULL, n_knots=8, seed=0, mesh=mesh, spde=spde_mod, pixels=predict_pixels, covs=NULL, spatiotemporal=T, verbose = F, n_trajectories = 10,
  preserve_inter_regional_differences = F)

spatio_temporal_censored_ind <-
  spatiotemp_censored_index_fun(data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=n_samp, return=T, ICR_adjust=F, cprop=0.95, nthreads=n_cores, keep=F, use_upper_bound=TRUE, upper_bound_quantile=0.95, plot=T, allyears=F, station_effects=T, prior_event=HT.prior(), prior_station=HT.prior(), init_vals = NULL, n_knots=8, seed=0, mesh=mesh, spde=spde_mod, pixels=predict_pixels, covs=NULL, spatiotemporal=T, verbose = F, n_trajectories = 10,
  preserve_inter_regional_differences = F)

```

```{r loadprecompiledspatiotemp, echo=FALSE, message=FALSE, warning=FALSE, cache=F}
# load pre-compiled model fits
list2env(hookcompetition::vignettes_precompiled_data, globalenv())

ggplot2::ggplot(spatio_temporal_CPUE_inddf, ggplot2::aes(x=year ,y=mean, ymin=q0.025, ymax=q0.975)) +
        ggplot2::geom_point() + ggplot2::geom_errorbar() + ggplot2::ylab('Catch rate index') + ggplot2::facet_grid(~region) +
        ggplot2::ggtitle(paste0('Spatiotemporal Overdispersed Poisson Index ','Yelloweye'))

ggplot2::ggplot(spatio_temporal_ICR_inddf, ggplot2::aes(x=year ,y=mean, ymin=q0.025, ymax=q0.975)) +
        ggplot2::geom_point() + ggplot2::geom_errorbar() + ggplot2::ylab('Catch rate index') + ggplot2::facet_grid(~region) +
                ggplot2::ggtitle(paste0('Spatiotemporal Overdispersed ICR-based Poisson Index ','Yelloweye'))

ggplot2::ggplot(spatio_temporal_censored_inddf, ggplot2::aes(x=year ,y=mean, ymin=q0.025, ymax=q0.975)) +
        ggplot2::geom_point() + ggplot2::geom_errorbar() + ggplot2::ylab('Catch rate index') + ggplot2::facet_grid(~region) +
        ggplot2::ggtitle(paste0('Spatiotemporal Overdispersed Censored Poisson Index yelloweye'), subtitle = 'censorship proportion 0.9, censorship from data in upper 10% of values removed')

ggplot2::ggplot(spatio_temporal_CPUE_trajectory, ggplot2::aes(x=year ,y=mean, colour=MC_ind, group=MC_ind)) +
          ggplot2::geom_line() + ggplot2::ylab('Catch rate index') + ggplot2::facet_grid(~region) +
          ggplot2::ggtitle(paste0('Overdispersed',' Poisson Index ','yelloweye')) +
          viridis::scale_color_viridis()

ggplot2::ggplot(spatio_temporal_ICR_trajectory, ggplot2::aes(x=year ,y=mean, colour=MC_ind, group=MC_ind)) +
          ggplot2::geom_line() + ggplot2::ylab('Catch rate index') + ggplot2::facet_grid(~region) +
          ggplot2::ggtitle(paste0('Overdispersed ICR-based',' Poisson Index ','yelloweye')) +
          viridis::scale_color_viridis()

ggplot2::ggplot(spatio_temporal_censored_trajectory, ggplot2::aes(x=year ,y=mean, colour=MC_ind, group=MC_ind)) +
          ggplot2::geom_line() + ggplot2::ylab('Catch rate index') + ggplot2::facet_grid(~region) +
          ggplot2::ggtitle(paste0('Overdispersed censored',' Poisson Index ','yelloweye'),
                  subtitle = 'Censorship defined as 95% or more baits removed \nCensorship removed from upper 10% of values each year') +          viridis::scale_color_viridis()


```

Now we plot maps of yelloweye density from the three spatio-temporal models in the year 2000 using the function `spatio_temporal_plot_fun()` which takes arguments:

- `pred_df_plot` the SpatialPixelsDataFrame output named `pred_df_plot` from the function `spatiotemp_censored_index_fun()`
- `year` integer specifying the desired year for plotting
- `variable` character specifying which variable to plot (e.g. mean, sd, etc.,)
- `hires_COAST` SpatialPolygonsDataFrame object with the high resolution coastline
- `plot_figure` Logical - Do you want to plot the figure?
- `return_figure` Logical - Do you want to return the figure?

```{r spatiotemporal_plot, eval=F, message=FALSE, warning=FALSE}
# plot the posterior mean yelloweye density on a map in year 2000
spatio_temporal_plot_fun(
  spatio_temporal_CPUE_plotdf, year=2000, variable='mean', 
  hires_COAST=Coast_hires, plot_figure=T, return_figure=F
)

# plot the posterior mean yelloweye density on a map in year 2000
spatio_temporal_plot_fun(
  spatio_temporal_ICR_plotdf, year=2000, variable='mean', 
  hires_COAST=Coast_hires, plot_figure=T, return_figure=F
)

# plot the posterior mean yelloweye density on a map in year 2000
spatio_temporal_plot_fun(
  spatio_temporal_censored_plotdf, year=2000, variable='mean', 
  hires_COAST=Coast_hires, plot_figure=T, return_figure=F
)

```

```{r plotprecompiledspatiotemp, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
ggplot2::ggplot() + inlabru::gg(spatio_temporal_CPUE_plotdf[which(spatio_temporal_CPUE_plotdf$year==2000), c('mean')]) + inlabru::gg(Coast_hires) + colsc(as.matrix(spatio_temporal_CPUE_plotdf[which(spatio_temporal_CPUE_plotdf$year==2000), c('mean')])) + ggplot2::ggtitle('CPUE-based yelloweye abundance in year 2000')

ggplot2::ggplot() + inlabru::gg(spatio_temporal_ICR_plotdf[which(spatio_temporal_ICR_plotdf$year==2000), c('mean')]) + inlabru::gg(Coast_hires) + colsc(as.matrix(spatio_temporal_ICR_plotdf[which(spatio_temporal_ICR_plotdf$year==2000), c('mean')])) + ggplot2::ggtitle('ICR-based yelloweye abundance in year 2000')

ggplot2::ggplot() + inlabru::gg(spatio_temporal_censored_plotdf[which(spatio_temporal_censored_plotdf$year==2000), c('mean')]) + inlabru::gg(Coast_hires) + colsc(as.matrix(spatio_temporal_censored_plotdf[which(spatio_temporal_censored_plotdf$year==2000), c('mean')])) + ggplot2::ggtitle('Censored Poisson yelloweye abundance in year 2000',subtitle = 'Censorship defined as 95% or more baits removed \nCensorship removed from upper 10% of values each year')
```
