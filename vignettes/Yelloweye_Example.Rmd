---
title: "Yellowe_Rockfish_Example"
author: "Joe Watson"
date: "28/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## How to use the hookCompetition package

This markdown document will outline the steps needed to use the hookCompetition package.

# Step 1 - Loading the packages.

```{r loadpackage}
library(hookcompetition)

```

# Step 2 - Loading the data.

The function `read_Data_hookcomp()` achieves this. The arguments to the function are:

- `species_vec` is a character vector of the one or more species desired for modelling
- `at_PBS` is a logical flag determining if the user has access to the gf data. If FALSE, yelloweye rockfish must be the specified species. 
- `simple_species_vec` is a character vector containing the desired shortened names of the species
- `data_wd` is a character vector stating the working directory where the rds files will be saved
- `min_dist` is a numeric stating the minimum distance (km) required for a temporary IPHC station to be from a permanent IPHC station to be included
- `min_dist_to_boundary` is a numeric stating the minimum distance (km) required for an IPHC station to be from the survey boundary
- `years_all_vec` is a numeric vector stating the years all hooks were enumerated
- `years_20_vec` is a numeric vector stating the years only 20 hooks were enumerated
- `survey_boundaries`   # survey_boundaries is a SpatialPolygonsDataFrame object containing user-specified survey boundaries for indices to be computed in. If NULL QCS, WCHG, WCVI, HS used. The data.frame *must* contain a factor variable `Region` with levels equal to the names of the regions


```{r loaddata, echo=F}

data <- hookcompetition::read_Data_hookcomp(
  species_vec = 'yelloweye rockfish',
  simple_species_vec = 'yelloweye',
  at_PBS = F,
  data_wd = './',
  min_dist = 50,
  min_dist_to_boundary = 0,
  years_all_vec = c(1995,1996,2003:2012, 2014:2019),
  years_20_vec = c(1997:2002, 2013, 2020),
  survey_boundaries=NULL
)

```

The function `read_Data_hookcomp()` returns a list containing two entries:
- `Reduced_data_sp` is a SpatialPointsDataFrame containing all the set-level catch counts of the species specified (variable name `N_it_yelloweye`).
- `survey_boundaries` are the survey boundaries projected into the same CRS as the `Reduced_data_sp` object.

To put the objects in the list into the current working environment, run the following:

```{r environment}
list2env(data, globalenv())
rm(data)
```


# Step 3 - Fit the indices without the spatio-temporal random effects. 

We derive bootstrap indices for a set of test species using the function `bootstrap_index_fun_run`. We derive an overall index and a subregion index (with subregions defined by the survey boundaries).

The function `bootstrap_index_fun_run` takes as arguments:

- `data` a SpatialPointsDataFrame object containing the IPHC data
- `species` a character name of the species (linked to the variables `N_it` in the dataframe)
- `survey_boundaries` a SpatialPolygonsDataFrame object containing the survey boundary definitions
- `R` specifies the number of bootstrap samples desired
- `ncpus` specifies the number of cores to use in parallel
- `type` specifies the type of bootstrap intervals to use (default percentile)
- `return` when TRUE it returns the indices
- `plot` when TRUE it returns the plot. 

```{r bootstrap, cache=F, warning=F, message=F}
boostrap_ind <-
bootstrap_index_fun_run(species_vec = 'yelloweye',
                          data = Reduced_data_sp,
                          survey_boundaries = survey_boundaries,
                          R=1000,
                          return=T,
                          ncpus=1,
                          type='perc',
                          plot=T
                          )

```

We derive hook-competition-adjusted bootstrap indices using the same function `bootstrap_index_fun_run()`, but adding the argument `ICR_adjust=TRUE`. We derive an overall index and a subregion index (with subregions defined by the survey boundaries).


```{r bootstrap_compfactor, cache=F, warning=F, message=F}
bootstrap_ind_compfactor <-
bootstrap_index_fun_run(species_vec = 'yelloweye',
                          data = Reduced_data_sp,
                          ICR_adjust=T,
                          survey_boundaries = survey_boundaries,
                          R=1000,
                          return=T,
                          ncpus=1,
                          type='perc',
                          plot=T
                          )
```

Finally, we compute Poisson-lognormal model-based indices of relative abundance. These include the CPUE-based (unadjusted), hook-competition-adjusted (ICR-based), and censored likelihood-based indices. 

To compute all three indices we use the function `censored_index_fun` with arguments:

- `data`
- `species`
- `survey_boundaries`
- `M` the number of independent Monte Carlo samples from the posterior used to compute indices
- `return` logical stating whether or not to return indices as a data.frame
- `ICR_adjust` A logical determining if the ICR-based scale-factor adjustment should be used
- `cprop` the minimum proportion of baits needed to induce censorship
- `nthreads` how many cores do you want to run in parallel when fitting the model
- `keep` a logical stating if you want to return the INLA model object
- `use_upper_bound` a logical stating if right-censored or interval-censored is desired
- `upper_bound_quantile` a proportion stating which quantiles of observation to remove censorship from. If greater than 1, do not remove censorship from any observation
- `plot` logical
- `allyears` logical determining if upper bound quantile is computed uniquely for each year (if False) or over all years (if TRUE)
- `station_effects` logical stating if IID station-station random effects wanted
- `prior_event` a prior distribution for the event-event IID random effect standard deviation (see HT.prior for default half t_7(0,1) distribution)
- `prior_station` a prior distribution for the station-station IID random effect standard deviation (see HT.prior for default half t_7(0,1) distribution)
- `init_vals` initial values for fitting model. If NULL let INLA choose them.
- `n_knots` the number of knots used for the temporal 'spline'. Default is 8. More knots means a 'wigglier' temporal effect is allowed.
- `seed` the seed used for Monte Carlo sampling. Note that 0 means the result is non-reproducible, but the code can be significantly faster.
- `verbose` logical. If TRUE, show INLA diagnostics as the model fits. Can help to diagnose issues.


We now fit all three indices

```{r model-based, cache=F, warning=F, message=F}
CPUE_ind <-
censored_index_fun(
  data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=1000, return=T, ICR_adjust=F, cprop=1.1, nthreads=1, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0
)

ICR_ind <-
censored_index_fun(
  data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=1000, return=T, ICR_adjust=T, cprop=1.1, nthreads=1, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0
)

# The following model does not converge
censored_ind <-
ensored_index_fun(
  data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=1000, return=T, ICR_adjust=F, cprop=0.95, nthreads=1, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0
    )

# Use upper bound and lower upper_bound_quantile to 0.98
censored_ind <-
ensored_index_fun(
  data=Reduced_data_sp, species='yelloweye', M=1000, return=T, ICR_adjust=F, cprop=0.95, nthreads=1, keep=F, use_upper_bound=TRUE, upper_bound_quantile=0.98, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0
    )

```

## Bonus

The package also allows for spatio-temporal indices to be fit

Step 5 load the R objects required for fitting spatio-temporal models. These include: a delauney triangulation mesh for computing the GMRF approximation to the SPDE (cite Lindgren) within r-INLA (cite Rue); an INLA spde object with user-specified pc priors specified on the range and standard deviation parameters. Note that the spde object is a barrier model (cite Bakka) which accounts for land as a barrier.

```{r makespatialobj, cache=F, warning=F, message=F}
spatial_obj <- make_spatial_objects(
  data=Reduced_data_sp,
  survey_boundaries = survey_boundaries,
  mesh_coast = NULL, hires_coast = NULL, 
  prior_range = 20, prior_range_prob = 0.01,
  prior_sigma = 2, prior_sigma_prob = 0.01 
)

# load it into the global envirionment
list2env(spatial_obj, globalenv())
rm(spatial_obj)

ggplot() + gg(mesh) + gg(inla.barrier.polygon(mesh, triangle_ind)) + gg(Reduced_data_sp)

```

# Step 6 Fit the spatio-temporal indices

```{r spatiotemporal, cache=F, warning=F, message=F}

spatio_temporal_CPUE_ind <-
  spatiotemp_censored_index_fun(data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=1000, return=T, ICR_adjust=F, cprop=1.1, nthreads=8, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0, mesh=mesh, spde=spde_mod, pixels=predict_pixels, covs=NULL, spatiotemporal=T, verbose = T)

# plot the posterior mean yelloweye density on a map in year 2000
spatio_temporal_plot_fun(
  spatio_temporal_CPUE_ind$pred_df_plot, year=2000, variable='mean', 
  hires_COAST=Coast_hires, plot_figure=T, return_figure=F
)

spatio_temporal_ICR_ind <-
  spatiotemp_censored_index_fun(data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=1000, return=T, ICR_adjust=T, cprop=1.1, nthreads=8, keep=F, use_upper_bound=FALSE, upper_bound_quantile=1.1, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0, mesh=mesh, spde=spde_mod, pixels=predict_pixels, covs=NULL, spatiotemporal=T, verbose = T)

# plot the posterior mean yelloweye density on a map in year 2000
spatio_temporal_plot_fun(
  spatio_temporal_ICR_ind$pred_df_plot, year=2000, variable='mean', 
  hires_COAST=Coast_hires, plot_figure=T, return_figure=F
)

spatio_temporal_censored_ind <-
  spatiotemp_censored_index_fun(data=Reduced_data_sp, survey_boundaries=survey_boundaries, species='yelloweye', M=1000, return=T, ICR_adjust=F, cprop=0.95, nthreads=8, keep=F, use_upper_bound=TRUE, upper_bound_quantile=0.98, plot=T, allyears=F, station_effects=T, prior_event=HT.prior, prior_station=HT.prior, init_vals = NULL, n_knots=8, seed=0, mesh=mesh, spde=spde_mod, pixels=predict_pixels, covs=NULL, spatiotemporal=T, verbose = T)

# plot the posterior mean yelloweye density on a map in year 2000
spatio_temporal_plot_fun(
  spatio_temporal_censored_ind$pred_df_plot, year=2000, variable='mean', 
  hires_COAST=Coast_hires, plot_figure=T, return_figure=F
)

```

